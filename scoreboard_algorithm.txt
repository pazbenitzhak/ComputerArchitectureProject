מנגנון scoreboard:
- כולל R_j , R_k , Q_j , Q_k , F_i , F_j , F_k , O_p , Busy לכל יחידה פונקציונלית
ויש לו 4 שלבים:
1.issue- לוקחים הוראה חדשה ומכניסים אותה ליחידה פונקציונלית (לפני זה עשינו fetch שהביא הוראות לתור הוראות).
- ממתינים ליחידה פונקציונלית פנויה (טיפול בstructual hazard)
- טיפול בhazard מסוג WAW - אם יש לי הוראה שרוצה לכתוב לרגיסטר בזמן שיש הוראה קודמת שכתבה לאותו רגיסטר שעדיין לא הסתיימה, נטפל בצורה נאיבית, פשוט נמתין (לא נעשה issue להוראה השניה שכותבת לאותו רגיסטר וכיוון שתור ההוראות הוא In order אני גם מעקב את כל ההוראות שאחר כך).
בפועל: ממתינים שרגיסטר dst לא יופיע כממתין ליחידה פונקציונלית.
אז לכל רגיסטר נצטרך להחזיק סטטוס שאומר האם הרגיסטר מוכן או ממתין ליחידה פונקציונלית.
- הכנסת ההוראה ליחידה: סימון Busy, העתקת Op , F (כל השלשה- i זה היעד וj,k הם המקורות), העתקת Q (שניהם) ממערך הרגיסטרים, אם Q קיים אז R מסומן כnot ready, אחרת ready ועדכון של היחידה הפונקציונלית במערך הרגיסטרים
2. שלב הread operands
- ממתינים לready (R_j , R_k) ששני האופרנדים יהיו מוכנים. זה למעשה הטיפול בRAW
- ברגע שהרגיסטרים מוכנים, עוברים לשלב הexecution, מאתחלים את R_j , R_k לNot ready (No), זה למעשה חלק מהטיפול בWAR כדי שההוראה שכותבת לרגיסטרים האלה לא תמתין סתם.
3. שלב הexecution - ממתינים לביצוע היחידה הפונקציונלית.
4. שלב הWrite Result:
- טיפול בWAR - עבור כל היחידות שמחכות לרגיסטר, ממתינים שיבצעו read operands על ידי כך שמחכים לR_j , R_k = No
- עדכון הרגיסטר ושינוי R_j , R_k  לyes בכל היחידות שממתינות. זה טיפול בRAW. ונמחק את Q_j , Q_k 
- עדכון busy של היחידה ל0
- מחיקה של היחידה מה register status